<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess GPT</title>
    <style>
        /* Base styles and typography */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }

        /* Layout containers */
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 1rem;
            box-sizing: border-box;
        }

        /* Header styling */
        .header {
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1rem;
            text-align: center;
            margin-bottom: 2rem;
        }

        /* Main content area */
        .content {
            background-color: #ffffff;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
        }

        /* Typography styles */
        h1 {
            color: #333;
            margin-bottom: 1rem;
        }
        p {
            color: #666;
            margin-bottom: 2rem;
        }

        /* Chess board layout and grid */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #333;
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
            aspect-ratio: 1;  /* Maintain square shape */
        }

        /* Individual square styling */
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            aspect-ratio: 1;
            min-height: 0;  /* Prevent content expansion */
            min-width: 0;   /* Prevent content expansion */
        }

        /* Chess board colors */
        .white { background-color: #f0d9b5; }  /* Light squares */
        .black { background-color: #b58863; }  /* Dark squares */

        /* Board coordinates */
        .coordinate {
            position: absolute;
            font-size: 12px;
            color: #666;
        }
        .file { bottom: 2px; right: 2px; }  /* a-h labels */
        .rank { top: 2px; left: 2px; }      /* 1-8 labels */

        /* Chess piece styling and positioning */
        .piece {
            cursor: grab;
            user-select: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: min(6vw, 40px);
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;  /* Allow clicks through to square */
            transition: all 0.3s ease-out;  /* Smooth transitions for all property changes */
        }
        .piece[draggable="true"] {
            pointer-events: auto;  /* Enable dragging */
        }
        .piece.dragging {
            cursor: grabbing;
            opacity: 0.8;
        }

        /* Selected square highlighting */
        .square.selected {
            position: relative;
        }
        .square.selected::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(144, 238, 144, 0.6);  /* Light green highlight */
            pointer-events: none;
        }

        /* Move status messages */
        #move-status {
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
            display: none;
        }
        .success { background-color: #d4edda; color: #155724; }  /* Success message */
        .error { background-color: #f8d7da; color: #721c24; }    /* Error message */

        /* Turn indicator and AI thinking animation */
        #turn-container {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            background-color: #e9ecef;
            margin-bottom: 1rem;
            height: 40px;
            width: 200px;
            position: relative;
            overflow: hidden;
        }
        #turn-indicator, #ai-thinking {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            transition: opacity 0.2s ease;
        }
        #turn-indicator {
            color: #495057;
            font-weight: bold;
            opacity: 1;
        }
        #ai-thinking {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            opacity: 0;
            pointer-events: none;
        }
        #ai-thinking.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #ai-thinking .spinner {
            font-size: 24px;
            animation: spin 2s infinite linear;
            line-height: 1;
            display: inline-block;
        }
        #ai-thinking .text {
            color: #495057;
            font-weight: bold;
        }

        /* Spinner animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Game controls and buttons */
        .game-controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
        }
        .game-btn {
            padding: 0.5rem 1rem;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
        }
        #new-game-btn {
            background-color: #28a745;
            margin-top: 0;
        }
        #new-game-btn:hover { background-color: #218838; }
        #resign-btn { background-color: #dc3545; }
        #resign-btn:hover { background-color: #c82333; }
        #resign-btn:disabled {
            background-color: #dc354580;
            cursor: not-allowed;
        }

        /* Status bar at bottom */
        .status-bar {
            margin-top: 2rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-top: 1px solid #dee2e6;
            border-radius: 0 0 8px 8px;
            width: 100%;
            max-width: 480px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Move analysis containers */
        #analysis-container {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: 100%;
            max-width: 480px;
            display: none;
        }
        #player-analysis, #ai-analysis {
            margin-bottom: 1rem;
            padding: 1rem;
            border-left: 4px solid;
            background-color: white;
            border-radius: 0 4px 4px 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #player-analysis { border-color: #28a745; }  /* Green for player */
        #ai-analysis { 
            border-color: #007bff;  /* Blue for AI */
            margin-top: 1rem; 
        }
        #analysis-title, #ai-analysis-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        #analysis-content, #ai-analysis-content {
            color: #6c757d;
            line-height: 1.5;
            font-style: italic;
        }

        /* Responsive design breakpoints */
        @media screen and (max-width: 600px) {
            /* Tablet and large phone adjustments */
            .container { padding: 0.5rem; }
            .content { padding: 0.5rem; }
            .header { margin-bottom: 1rem; }
            h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
            p { margin-bottom: 1rem; }
            .coordinate { font-size: 10px; }
            #analysis-container { padding: 0.5rem; }
            .game-btn {
                padding: 0.5rem 1rem;
                font-size: 0.8rem;
            }
            .status-bar {
                margin-top: 1rem;
                padding: 0.5rem;
            }
        }

        @media screen and (max-width: 400px) {
            /* Small phone adjustments */
            .piece { font-size: min(8vw, 40px); }
            .game-controls { gap: 0.5rem; }
            .game-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.7rem;
            }
        }

        @media screen and (orientation: landscape) and (max-height: 600px) {
            /* Landscape mode optimizations */
            .container {
                display: flex;
                flex-direction: row;
                align-items: flex-start;
                gap: 1rem;
            }
            .chess-board {
                max-height: 80vh;
                width: auto;
            }
            .content {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 1rem;
            }
            #analysis-container { max-width: 300px; }
        }
    </style>
</head>
<body>
    <!-- Page header -->
    <div class="header">
        <h1>{{ title }}</h1>
    </div>

    <!-- Main container -->
    <div class="container">
        <div class="content">
            <!-- Turn indicator and AI thinking animation -->
            <div id="turn-container">
                <div id="turn-indicator">White to move</div>
                <div id="ai-thinking">
                    <span class="spinner">♟</span>
                    <span class="text">AI is thinking...</span>
                </div>
            </div>

            <!-- Player color message -->
            <p>{{ message }}</p>

            <!-- Chess board grid -->
            <div class="chess-board" data-player-color="{{ player_color }}">
                {% for row in range(8) %}
                    {% for col in range(8) %}
                        <!-- Chess square with coordinates and piece -->
                        <div class="square {{ 'white' if (row + col) % 2 == 0 else 'black' }}"
                             data-row="{{ row }}" 
                             data-col="{{ col }}">
                            <!-- File labels (a-h) on bottom row -->
                            {% if row == 7 %}
                                <span class="coordinate file">{{ ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'][col] }}</span>
                            {% endif %}
                            <!-- Rank labels (1-8) on leftmost column -->
                            {% if col == 0 %}
                                <span class="coordinate rank">{{ 8 - row }}</span>
                            {% endif %}
                            <!-- Chess piece -->
                            <span class="piece" draggable="true">{{ board[row][col] }}</span>
                        </div>
                    {% endfor %}
                {% endfor %}
            </div>

            <!-- Move status messages -->
            <div id="move-status"></div>

            <!-- Move analysis section -->
            <div id="analysis-container">
                <!-- Player's move analysis -->
                <div id="player-analysis">
                    <div id="analysis-title">Your Move Analysis:</div>
                    <div id="analysis-content"></div>
                </div>
                <!-- AI's move analysis -->
                <div id="ai-analysis" style="display: none;">
                    <div id="ai-analysis-title">AI Move Analysis:</div>
                    <div id="ai-analysis-content"></div>
                </div>
            </div>

            <!-- Game control buttons -->
            <div class="status-bar">
                <div class="game-controls">
                    <button id="new-game-btn" class="game-btn" onclick="startNewGame()">New Game</button>
                    <button id="resign-btn" class="game-btn" onclick="resignGame()">Resign</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game logic script -->
    <script>
        // Global variables to track game state
        let selectedPiece = null;      // Currently selected chess piece
        let selectedSquare = null;     // Square containing the selected piece
        let isGameOver = false;        // Track if the game has ended
        let canPlayerMove = true;      // Track if the player can make a move
        const playerColor = document.querySelector('.chess-board').dataset.playerColor;  // Player's chosen color (white/black)

        /**
         * Clears the currently selected piece and square
         * Removes visual highlighting from the board
         */
        function clearSelection() {
            if (selectedSquare) {
                selectedSquare.classList.remove('selected');
            }
            selectedPiece = null;
            selectedSquare = null;
        }

        /**
         * Handles clicking on a chess square
         * Manages piece selection and move validation
         * @param {Event} e - Click event
         */
        function handleSquareClick(e) {
            // Prevent moves if game is over
            if (isGameOver) {
                showMoveStatus('Game is over! Start a new game.', false);
                return;
            }

            const clickedSquare = e.target.closest('.square');
            const clickedPiece = clickedSquare.querySelector('.piece');

            // First click - Selecting a piece
            if (!selectedPiece) {
                // Ignore clicks on empty squares
                if (clickedPiece.textContent.trim() === '') {
                    return;
                }

                // Validate piece color and turn
                const pieceColor = getPieceColor(clickedPiece.textContent);
                const currentTurn = document.getElementById('turn-indicator').textContent.split(' ')[0].toLowerCase();

                if (pieceColor !== currentTurn || pieceColor !== playerColor) {
                    showMoveStatus(`It's ${currentTurn}'s turn to move!`, false);
                    return;
                }

                // Select the piece
                selectedPiece = clickedPiece;
                selectedSquare = clickedSquare;
                selectedSquare.classList.add('selected');
            } 
            // Second click - Moving the piece
            else {
                // Prevent making the move if AI is thinking
                if (!canPlayerMove) {
                    showMoveStatus('Please wait for Black to make a move before proceeding.', false);
                    return;
                }

                // Clicking the same square deselects the piece
                if (clickedSquare === selectedSquare) {
                    clearSelection();
                    return;
                }

                // Attempt to make the move
                const fromRow = parseInt(selectedSquare.dataset.row);
                const fromCol = parseInt(selectedSquare.dataset.col);
                const toRow = parseInt(clickedSquare.dataset.row);
                const toCol = parseInt(clickedSquare.dataset.col);

                // Check if the destination square is empty or contains an opponent's piece
                const destinationPiece = clickedSquare.querySelector('.piece').textContent.trim();
                if (destinationPiece !== '') {
                    const destinationPieceColor = getPieceColor(destinationPiece);
                    const selectedPieceColor = getPieceColor(selectedPiece.textContent);
                    
                    // If destination has a piece of the same color, invalid move
                    if (destinationPieceColor === selectedPieceColor) {
                        showMoveStatus('Invalid move! Cannot capture your own piece.', false);
                        clearSelection();
                        return;
                    }
                }

                makeMove(fromRow, fromCol, toRow, toCol, selectedPiece, clickedSquare.querySelector('.piece'));
                clearSelection();
            }
        }

        /**
         * Initiates a chess move and communicates with the server
         * @param {number} fromRow - Starting row
         * @param {number} fromCol - Starting column
         * @param {number} toRow - Target row
         * @param {number} toCol - Target column
         * @param {Element} fromPiece - Piece being moved
         * @param {Element} toPiece - Piece at target square (if any)
         */
        function isCastlingAttempt(fromPiece, fromCol, toCol) {
            return get_piece_type(fromPiece.textContent) === 'king' && Math.abs(toCol - fromCol) === 2;
        }

        function isPathClear(row, fromCol, toCol) {
            const step = fromCol < toCol ? 1 : -1;
            for (let col = fromCol + step; col !== toCol; col += step) {
                const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                if (square.querySelector('.piece').textContent.trim() !== '') {
                    return false;
                }
            }
            return true;
        }

        function get_piece_type(piece) {
            const pieceTypes = {
                '♔': 'king', '♚': 'king',
                '♕': 'queen', '♛': 'queen',
                '♖': 'rook', '♜': 'rook',
                '♗': 'bishop', '♝': 'bishop',
                '♘': 'knight', '♞': 'knight',
                '♙': 'pawn', '♟': 'pawn'
            };
            return pieceTypes[piece] || null;
        }

        function makeMove(fromRow, fromCol, toRow, toCol, fromPiece, toPiece) {
            // Store original board state for move reversal if needed
            const originalFromContent = fromPiece.textContent;
            const originalToContent = toPiece.textContent;

            // Check if this is a castling attempt
            const isCastling = isCastlingAttempt(fromPiece, fromCol, toCol);
            
            let castlingState = null;
            if (isCastling) {
                // Quick frontend validation for castling
                const isQueenside = toCol < fromCol;
                const rookCol = isQueenside ? 0 : 7;
                const rookSquare = document.querySelector(`.square[data-row="${fromRow}"][data-col="${rookCol}"]`);
                const rookPiece = rookSquare.querySelector('.piece');
                const expectedRook = playerColor === 'white' ? '♖' : '♜';
                
                if (rookPiece.textContent !== expectedRook || !isPathClear(fromRow, fromCol, toCol)) {
                    showMoveStatus('Invalid castling move! Path must be clear.', false);
                    return;
                }

                const newRookCol = toCol + (isQueenside ? 1 : -1);
                const newRookSquare = document.querySelector(`.square[data-row="${fromRow}"][data-col="${newRookCol}"]`);
                
                // Store castling state for potential reversal
                castlingState = {
                    rookSquare,
                    rookPiece,
                    newRookSquare,
                    originalKingContent: fromPiece.textContent,
                    originalKingSquareContent: '',
                    originalRookContent: rookPiece.textContent,
                    originalNewRookSquareContent: newRookSquare.querySelector('.piece').textContent
                };

                // Update UI for king with animation
                fromPiece.style.transition = 'all 0.3s ease-out';
                toPiece.style.transition = 'all 0.3s ease-out';
                
                fromPiece.style.opacity = '0';
                toPiece.style.opacity = '0';
                fromPiece.style.transform = 'translate(-50%, -50%) scale(0.8)';
                toPiece.style.transform = 'translate(-50%, -50%) scale(1.2)';
                
                setTimeout(() => {
                    toPiece.textContent = fromPiece.textContent;
                    fromPiece.textContent = '';
                    
                    fromPiece.style.opacity = '1';
                    toPiece.style.opacity = '1';
                    fromPiece.style.transform = 'translate(-50%, -50%) scale(1)';
                    toPiece.style.transform = 'translate(-50%, -50%) scale(1)';
                    
                    setTimeout(() => {
                        fromPiece.style.transition = '';
                        toPiece.style.transition = '';
                        fromPiece.style.transform = 'translate(-50%, -50%)';
                        toPiece.style.transform = 'translate(-50%, -50%)';
                    }, 300);
                }, 300);

                // Update UI for rook with animation
                rookPiece.style.transition = 'all 0.3s ease-out';
                newRookSquare.querySelector('.piece').style.transition = 'all 0.3s ease-out';
                
                rookPiece.style.opacity = '0';
                newRookSquare.querySelector('.piece').style.opacity = '0';
                rookPiece.style.transform = 'translate(-50%, -50%) scale(0.8)';
                newRookSquare.querySelector('.piece').style.transform = 'translate(-50%, -50%) scale(1.2)';
                
                setTimeout(() => {
                    newRookSquare.querySelector('.piece').textContent = rookPiece.textContent;
                    rookPiece.textContent = '';
                    
                    rookPiece.style.opacity = '1';
                    newRookSquare.querySelector('.piece').style.opacity = '1';
                    rookPiece.style.transform = 'translate(-50%, -50%) scale(1)';
                    newRookSquare.querySelector('.piece').style.transform = 'translate(-50%, -50%) scale(1)';
                    
                    setTimeout(() => {
                        rookPiece.style.transition = '';
                        newRookSquare.querySelector('.piece').style.transition = '';
                        rookPiece.style.transform = 'translate(-50%, -50%)';
                        newRookSquare.querySelector('.piece').style.transform = 'translate(-50%, -50%)';
                    }, 300);
                }, 300);
            } else {
                // Update UI for regular moves with animation
                fromPiece.style.transition = 'all 0.3s ease-out';
                toPiece.style.transition = 'all 0.3s ease-out';
                
                fromPiece.style.opacity = '0';
                toPiece.style.opacity = '0';
                fromPiece.style.transform = 'translate(-50%, -50%) scale(0.8)';
                toPiece.style.transform = 'translate(-50%, -50%) scale(1.2)';
                
                setTimeout(() => {
                    toPiece.textContent = fromPiece.textContent;
                    fromPiece.textContent = '';
                    
                    fromPiece.style.opacity = '1';
                    toPiece.style.opacity = '1';
                    fromPiece.style.transform = 'translate(-50%, -50%) scale(1)';
                    toPiece.style.transform = 'translate(-50%, -50%) scale(1)';
                    
                    setTimeout(() => {
                        fromPiece.style.transition = '';
                        toPiece.style.transition = '';
                        fromPiece.style.transform = 'translate(-50%, -50%)';
                        toPiece.style.transform = 'translate(-50%, -50%)';
                    }, 300);
                }, 300);
            }

            // Show AI thinking indicator with delay
            const thinkingTimeout = setTimeout(() => {
                showAIThinking();
                canPlayerMove = false;  // Disable player moves while AI is thinking
            }, 500);

            // Send move to server for validation and AI response
            fetch('/move', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    from_row: fromRow,
                    from_col: fromCol,
                    to_row: toRow,
                    to_col: toCol
                })
            })
            .then(response => response.json())
            .then(data => {
                // Hide AI thinking indicator
                clearTimeout(thinkingTimeout);
                hideAIThinking();
                canPlayerMove = true;  // Re-enable player moves after AI responds

                if (data.valid) {
                    handleValidMove(data);
                } else {
                    // Revert move UI if invalid
                    if (isCastling && castlingState) {
                        // Revert king
                        fromPiece.textContent = castlingState.originalKingContent;
                        toPiece.textContent = castlingState.originalKingSquareContent;
                        
                        // Revert rook with animation
                        castlingState.rookPiece.style.transition = 'opacity 0.3s';
                        castlingState.newRookSquare.querySelector('.piece').style.transition = 'opacity 0.3s';
                        
                        castlingState.rookPiece.style.opacity = '0';
                        castlingState.newRookSquare.querySelector('.piece').style.opacity = '0';
                        
                        setTimeout(() => {
                            castlingState.rookPiece.textContent = castlingState.originalRookContent;
                            castlingState.newRookSquare.querySelector('.piece').textContent = castlingState.originalNewRookSquareContent;
                            
                            castlingState.rookPiece.style.opacity = '1';
                            castlingState.newRookSquare.querySelector('.piece').style.opacity = '1';
                            
                            setTimeout(() => {
                                castlingState.rookPiece.style.transition = '';
                                castlingState.newRookSquare.querySelector('.piece').style.transition = '';
                            }, 300);
                        }, 300);
                    } else {
                        // Revert regular move
                        fromPiece.textContent = originalFromContent;
                        toPiece.textContent = originalToContent;
                    }
                    showMoveStatus(data.message, false);
                }
            })
            .catch(error => {
                // Handle errors and revert move
                clearTimeout(thinkingTimeout);
                hideAIThinking();
                fromPiece.textContent = originalFromContent;
                toPiece.textContent = originalToContent;
                console.error('Error:', error);
                showMoveStatus('Error making move!', false);
            });

            console.log(`Attempting to move from (${fromRow}, ${fromCol}) to (${toRow}, ${toCol})`);

            // Check if the move is a castling move
            if (fromPiece.textContent === '♔' && Math.abs(toCol - fromCol) === 2) {
                console.log('Castling move detected.');
            }
        }

        /**
         * Processes server response after a valid move
         * Updates game state, UI, and displays analysis
         * @param {Object} data - Server response data
         */
        function animateRookMove(castlingInfo) {
            const rookFromSquare = document.querySelector(
                `.square[data-row="${castlingInfo.row}"][data-col="${castlingInfo.rook_from_col}"]`
            );
            const rookToSquare = document.querySelector(
                `.square[data-row="${castlingInfo.row}"][data-col="${castlingInfo.rook_to_col}"]`
            );

            if (rookFromSquare && rookToSquare) {
                const rookPiece = rookFromSquare.querySelector('.piece');
                const targetSpot = rookToSquare.querySelector('.piece');
                
                // Set up animation
                rookPiece.style.transition = 'all 0.3s ease-out';
                targetSpot.style.transition = 'all 0.3s ease-out';
                
                // Fade out and scale
                rookPiece.style.opacity = '0';
                targetSpot.style.opacity = '0';
                rookPiece.style.transform = 'translate(-50%, -50%) scale(0.8)';
                targetSpot.style.transform = 'translate(-50%, -50%) scale(1.2)';
                
                // Move the rook piece
                setTimeout(() => {
                    targetSpot.textContent = rookPiece.textContent;
                    rookPiece.textContent = '';
                    
                    // Fade in and normalize scale
                    rookPiece.style.opacity = '1';
                    targetSpot.style.opacity = '1';
                    rookPiece.style.transform = 'translate(-50%, -50%) scale(1)';
                    targetSpot.style.transform = 'translate(-50%, -50%) scale(1)';
                    
                    // Clean up transitions
                    setTimeout(() => {
                        rookPiece.style.transition = '';
                        targetSpot.style.transition = '';
                        rookPiece.style.transform = 'translate(-50%, -50%)';
                        targetSpot.style.transform = 'translate(-50%, -50%)';
                    }, 300);
                }, 300);
            }
        }

        function handleValidMove(data) {
            const turnIndicator = document.getElementById('turn-indicator');
            
            // Log the move details
            // Display move analysis if available
            if (data.move_analysis) {
                showMoveAnalysis(data.move_analysis, data.ai_move_analysis);
            }

            // Handle castling if applicable
            if (data.castling_info) {
                setTimeout(() => animateRookMove(data.castling_info), 300);
            }
            
            if (data.game_over) {
                // Handle game over state
                isGameOver = true;
                turnIndicator.textContent = `${data.winner} wins!`;
                turnIndicator.classList.add('game-over');
                turnIndicator.classList.remove('in-check');
                showMoveStatus(data.message, true);
                document.getElementById('resign-btn').disabled = true;
            } else {
                // Handle AI's move if present
                if (data.ai_move) {
                    showAIMove(data.ai_move);
                    // Handle AI castling if applicable
                    if (data.ai_move && data.ai_move.castling_info) {
                        setTimeout(() => animateRookMove(data.ai_move.castling_info), 600);
                    }
                    turnIndicator.textContent = 
                        `${data.current_turn.charAt(0).toUpperCase() + data.current_turn.slice(1)} to move`;
                    
                    // Update check status
                    if (data.in_check) {
                        turnIndicator.classList.add('in-check');
                        showMoveStatus(data.message, true);
                    } else {
                        turnIndicator.classList.remove('in-check');
                    }
                }
            }
        }

        /**
         * Displays move analysis for both player and AI
         * @param {string} playerAnalysis - Analysis of player's move
         * @param {string} aiAnalysis - Analysis of AI's move
         */
        function showMoveAnalysis(playerAnalysis, aiAnalysis) {
            const container = document.getElementById('analysis-container');
            const playerContent = document.getElementById('analysis-content');
            const aiContainer = document.getElementById('ai-analysis');
            const aiContent = document.getElementById('ai-analysis-content');
            
            // Update player's analysis
            playerContent.textContent = playerAnalysis;
            
            // Update AI's analysis if available
            if (aiAnalysis) {
                aiContainer.style.display = 'block';
                aiContent.textContent = aiAnalysis;
            } else {
                aiContainer.style.display = 'none';
            }
            
            container.style.display = 'block';
        }

        /**
         * Shows temporary status messages
         * @param {string} message - Status message to display
         * @param {boolean} success - Whether the message indicates success
         */
        function showMoveStatus(message, success) {
            const statusDiv = document.getElementById('move-status');
            statusDiv.textContent = message;
            statusDiv.className = success ? 'success' : 'error';
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 2000);
        }

        /**
         * Handles game restart
         * Confirms with user before reloading
         */
        function startNewGame() {
            if (!isGameOver && !confirm('Are you sure you want to start a new game?')) {
                return;
            }
            location.reload();
        }

        /**
         * Handles game resignation
         * Confirms with user and updates game state
         */
        function resignGame() {
            if (isGameOver) return;
            
            if (confirm('Are you sure you want to resign?')) {
                isGameOver = true;
                const turnIndicator = document.getElementById('turn-indicator');
                const winner = playerColor === 'white' ? 'Black' : 'White';
                turnIndicator.textContent = `${winner} wins by resignation!`;
                turnIndicator.classList.add('game-over');
                turnIndicator.classList.remove('in-check');
                showMoveStatus(`Game Over! ${winner} wins by resignation!`, true);
                document.getElementById('resign-btn').disabled = true;
                
                // Auto-restart after delay
                setTimeout(() => {
                    location.reload();
                }, 2000);
            }
        }

        /**
         * Determines the color of a chess piece
         * @param {string} piece - Unicode chess piece character
         * @returns {string|null} Color of the piece ('white'/'black') or null
         */
        function getPieceColor(piece) {
            const whitePieces = '♔♕♖♗♘♙';
            const blackPieces = '♚♛♜♝♞♟';
            if (whitePieces.includes(piece)) return 'white';
            if (blackPieces.includes(piece)) return 'black';
            return null;
        }

        /**
         * Displays and animates AI's move on the board
         * @param {Object} move - AI move coordinates
         */
        function showAIMove(move) {
            if (!move) return;
            
            // Clear any existing highlights
            document.querySelectorAll('.ai-move-highlight').forEach(square => {
                square.classList.remove('ai-move-highlight');
            });
            
            // Get source and target squares
            const fromSquare = document.querySelector(
                `.square[data-row="${move.from_row}"][data-col="${move.from_col}"]`
            );
            const toSquare = document.querySelector(
                `.square[data-row="${move.to_row}"][data-col="${move.to_col}"]`
            );
            
            if (fromSquare && toSquare) {
                // Highlight the move
                fromSquare.classList.add('ai-move-highlight');
                toSquare.classList.add('ai-move-highlight');
                
                // Get pieces for animation
                const fromPiece = fromSquare.querySelector('.piece');
                const toPiece = toSquare.querySelector('.piece');
                const pieceToMove = fromPiece.textContent;
                
                // Set up animation
                fromPiece.style.transition = 'all 0.3s ease-out';
                toPiece.style.transition = 'all 0.3s ease-out';
                
                // Fade out and scale
                fromPiece.style.opacity = '0';
                toPiece.style.opacity = '0';
                fromPiece.style.transform = 'translate(-50%, -50%) scale(0.8)';
                toPiece.style.transform = 'translate(-50%, -50%) scale(1.2)';
                
                // Update pieces after fade
                setTimeout(() => {
                    fromPiece.textContent = '';
                    toPiece.textContent = pieceToMove;
                    
                    // Fade in and normalize scale
                    fromPiece.style.opacity = '1';
                    toPiece.style.opacity = '1';
                    fromPiece.style.transform = 'translate(-50%, -50%) scale(1)';
                    toPiece.style.transform = 'translate(-50%, -50%) scale(1)';
                    
                    // Clean up transitions
                    setTimeout(() => {
                        fromPiece.style.transition = '';
                        toPiece.style.transition = '';
                        fromPiece.style.transform = 'translate(-50%, -50%)';
                        toPiece.style.transform = 'translate(-50%, -50%)';
                    }, 300);
                }, 300);
                
                // Remove highlights after delay
                setTimeout(() => {
                    fromSquare.classList.remove('ai-move-highlight');
                    toSquare.classList.remove('ai-move-highlight');
                }, 2000);
            }
        }

        /**
         * Shows the AI thinking indicator
         * Fades out turn indicator and fades in thinking animation
         */
        function showAIThinking() {
            document.getElementById('turn-indicator').style.opacity = '0';
            const aiThinking = document.getElementById('ai-thinking');
            aiThinking.style.display = 'flex';
            // Force a reflow for smooth animation
            void aiThinking.offsetWidth;
            aiThinking.classList.add('visible');
        }

        /**
         * Hides the AI thinking indicator
         * Fades out thinking animation and fades in turn indicator
         */
        function hideAIThinking() {
            document.getElementById('turn-indicator').style.opacity = '1';
            const aiThinking = document.getElementById('ai-thinking');
            aiThinking.classList.remove('visible');
            setTimeout(() => {
                aiThinking.style.display = 'none';
            }, 200);
        }

        // Initialize game state and event listeners
        document.getElementById('resign-btn').disabled = isGameOver;

        // Add click handlers for squares
        document.querySelectorAll('.square').forEach(square => {
            square.addEventListener('click', handleSquareClick);
            square.addEventListener('dragover', handleDragOver);
            square.addEventListener('drop', handleDrop);
        });

        // Add drag-and-drop handlers for pieces
        document.querySelectorAll('.piece').forEach(piece => {
            piece.addEventListener('dragstart', handleDragStart);
            piece.addEventListener('dragend', handleDragEnd);
        });

        /**
         * Handles the start of a drag operation
         * Validates the move and updates visual state
         * @param {DragEvent} e - Drag start event
         */
        function handleDragStart(e) {
            if (isGameOver) {
                e.preventDefault();
                showMoveStatus('Game is over! Start a new game.', false);
                return;
            }

            const piece = e.target;
            if (piece.textContent.trim() === '') {
                e.preventDefault();
                return;
            }

            const pieceColor = getPieceColor(piece.textContent);
            const currentTurn = document.getElementById('turn-indicator').textContent.split(' ')[0].toLowerCase();
            
            if (pieceColor !== currentTurn || pieceColor !== playerColor) {
                e.preventDefault();
                showMoveStatus(`It's ${currentTurn}'s turn to move!`, false);
                return;
            }

            e.target.classList.add('dragging');
            selectedPiece = e.target;
            selectedSquare = e.target.parentElement;
            selectedSquare.classList.add('selected');
        }

        /**
         * Handles the end of a drag operation
         * Cleans up visual state
         * @param {DragEvent} e - Drag end event
         */
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            if (selectedSquare) {
                selectedSquare.classList.remove('selected');
            }
            clearSelection();
        }

        /**
         * Allows dropping on squares
         * @param {DragEvent} e - Drag over event
         */
        function handleDragOver(e) {
            e.preventDefault();
        }

        /**
         * Handles piece drops on squares
         * Validates and executes the move
         * @param {DragEvent} e - Drop event
         */
        function handleDrop(e) {
            e.preventDefault();
            const targetSquare = e.target.closest('.square');
            if (!targetSquare || !selectedPiece) return;

            // Check if the destination square contains an opponent's piece
            const destinationPiece = targetSquare.querySelector('.piece').textContent.trim();
            if (destinationPiece !== '') {
                const destinationPieceColor = getPieceColor(destinationPiece);
                const selectedPieceColor = getPieceColor(selectedPiece.textContent);
                
                // If destination has a piece of the same color, invalid move
                if (destinationPieceColor === selectedPieceColor) {
                    showMoveStatus('Invalid move! Cannot capture your own piece.', false);
                    clearSelection();
                    return;
                }
            }

            const fromRow = parseInt(selectedSquare.dataset.row);
            const fromCol = parseInt(selectedSquare.dataset.col);
            const toRow = parseInt(targetSquare.dataset.row);
            const toCol = parseInt(targetSquare.dataset.col);

            makeMove(fromRow, fromCol, toRow, toCol, selectedPiece, targetSquare.querySelector('.piece'));
            clearSelection();
        }
    </script>
</body>
</html>
